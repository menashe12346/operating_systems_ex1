#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <limits.h>

// Function to generate random array
int* generate_random_input(int size, int seed) { 
    srand(seed);
    /*
    The rand function generates a sequence of pseudo-random numbers. These numbers are not truly random but are generated by an algorithm.
    Without seeding, the sequence of numbers generated by rand is the same each time the program runs.
    The srand function sets the seed for the random number generator used by rand.
    Without seeding (or using a constant seed), the sequence of random numbers will be the same on each program execution.
    we want different sequences of random numbers each time we run the program, so this why we use a different seed value each time.
    */
    int *input = (int *)malloc(size * sizeof(int)); //Memory Allocation for the Array
    for (int i = 0; i < size; ++i) {
        input[i] = rand() % 100 - 25; //Generating Random Numbers between (-25,74)
    }
    return input;
}

// O(n^3) solution
int max_sub_array_sum_n3(int* arr, int size) { //It iterates through all possible subarrays and calculates their sums.
    int max_sum = INT_MIN;
    for (int i = 0; i < size; ++i) {
        for (int j = i; j < size; ++j) {
            int current_sum = 0;
            for (int k = i; k <= j; ++k) {
                current_sum += arr[k];
            }
            if (current_sum > max_sum) {
                max_sum = current_sum;
            }
        }
    }
    return max_sum;
}

// O(n^2) solution
int max_sub_array_sum_n2(int* arr, int size) { //also iterates through all possible subarrays and calculates their sums.
    int max_sum = INT_MIN;
    for (int i = 0; i < size; ++i) {
        int current_sum = 0;
        for (int j = i; j < size; ++j) {
            current_sum += arr[j];
            if (current_sum > max_sum) {
                max_sum = current_sum;
            }
        }
    }
    return max_sum;
}

// O(n) solution (Kadane's Algorithm)
int max_sub_array_sum_n(int* arr, int size) {
    int max_sum = INT_MIN;
    int current_sum = 0;
    for (int i = 0; i < size; ++i) {
        current_sum = (arr[i] > current_sum + arr[i]) ? arr[i] : current_sum + arr[i];
        max_sum = (max_sum > current_sum) ? max_sum : current_sum;
        /*
        The algorithm iterates through each element of the array.
        At each step, it updates current_sum to be the maximum of the current element alone or the current element added to current_sum from the previous step. This decision effectively either starts a new subarray or extends the current subarray.
        It then updates max_sum to be the maximum of max_sum and current_sum.
        */
    }
    return max_sum;
}

int main(int argc, char* argv[]) {
    if (argc != 3) {
        fprintf(stderr, "need 2 arguments");
        return 1;
    }

    int seed = atoi(argv[1]); //to int
    int size = atoi(argv[2]); //to int

    // Generate random input
    int* input = generate_random_input(size, seed);

    // Measure and print runtime of O(n) solution
    clock_t start_time = clock(); //get the current processor time
    int max_sum_n = max_sub_array_sum_n(input, size);
    clock_t end_time = clock();
    printf("O(n) solution max sum: %d runtime: %f seconds\n", max_sum_n, (double)(end_time - start_time) / CLOCKS_PER_SEC);
    /*
    CLOCKS_PER_SEC is a macro defined in the <time.h> header file.
    It represents the number of clock ticks per second used by the system cloc so we use it to onvert the time from clock ticks to seconds.

    */

    // Measure and print runtime of O(n^2) solution
    start_time = clock();
    int max_sum_n2 = max_sub_array_sum_n2(input, size);
    end_time = clock();
    printf("O(n^2) solution max sum: %d runtime: %f seconds\n", max_sum_n2, (double)(end_time - start_time) / CLOCKS_PER_SEC);

    // Measure and print runtime of O(n^3) solution
    start_time = clock();
    int max_sum_n3 = max_sub_array_sum_n3(input, size);
    end_time = clock();
    printf("O(n^3) solution max sum: %d runtime: %f seconds\n", max_sum_n3, (double)(end_time - start_time) / CLOCKS_PER_SEC);

    free(input);
    return 0;
}
